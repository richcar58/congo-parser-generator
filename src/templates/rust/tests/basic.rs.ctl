//! Basic tests for ${settings.parserClassName}. Generated by ${generated_by}.

use ${settings.parserPackage?replace(".", "_")}::*;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_input() {
        let result = Parser::new("".to_string());
        // Empty input should fail or return EOF depending on grammar
        assert!(result.is_ok());
    }

    #[test]
    fn test_parser_creation() {
        let input = "test".to_string();
        let result = Parser::new(input);
        // Parser should be created successfully
        assert!(result.is_ok());
    }

    #[test]
    fn test_lexer_eof() {
        let mut lexer = Lexer::new("".to_string());
        let token = lexer.next_token().unwrap();
        assert_eq!(token.token_type, TokenType::EOF);
    }

    #[test]
    fn test_arena_allocation() {
        let mut arena = Arena::new();

        // Allocate a token
        let tok = arena.alloc_token(Token::new(
            TokenType::EOF,
            "".to_string(),
            0,
            0
        ));

        // Verify we can retrieve it
        let retrieved = arena.get_token(tok);
        assert_eq!(retrieved.token_type, TokenType::EOF);
    }

    #[test]
    fn test_error_display() {
        let err = ParseError::new("Test error");
        let display = format!("{}", err);
        assert!(display.contains("Test error"));

        let err_with_pos = ParseError::at_position("Test error", 10);
        let display_pos = format!("{}", err_with_pos);
        assert!(display_pos.contains("position 10"));
    }
}
