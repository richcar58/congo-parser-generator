//! Arena allocator for AST nodes. Generated by ${generated_by}. Do not edit.

use crate::tokens::Token;

/// Type-safe index for nodes in the arena
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct NodeId(pub usize);

/// Type-safe index for tokens in the arena
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct TokenId(pub usize);

/// Arena that owns all AST nodes and tokens
pub struct Arena {
    /// All AST nodes
    nodes: Vec<AstNode>,
    /// All tokens
    tokens: Vec<Token>,
}

impl Arena {
    /// Create a new empty arena
    pub fn new() -> Self {
        Arena {
            nodes: Vec::new(),
            tokens: Vec::new(),
        }
    }

    /// Allocate a new node in the arena
    pub fn alloc_node(&mut self, node: AstNode) -> NodeId {
        let id = NodeId(self.nodes.len());
        self.nodes.push(node);
        id
    }

    /// Get a reference to a node
    pub fn get_node(&self, id: NodeId) -> &AstNode {
        &self.nodes[id.0]
    }

    /// Get a mutable reference to a node
    pub fn get_node_mut(&mut self, id: NodeId) -> &mut AstNode {
        &mut self.nodes[id.0]
    }

    /// Allocate a new token in the arena
    pub fn alloc_token(&mut self, token: Token) -> TokenId {
        let id = TokenId(self.tokens.len());
        self.tokens.push(token);
        id
    }

    /// Get a reference to a token
    pub fn get_token(&self, id: TokenId) -> &Token {
        &self.tokens[id.0]
    }
}

impl Default for Arena {
    fn default() -> Self {
        Self::new()
    }
}

[#if grammar.productionTable?size > 0]
/// Enum containing all AST node types
#[derive(Debug, Clone)]
pub enum AstNode {
[#list grammar.parserProductions as production]
    /// AST node: ${production.name}
    ${production.name?cap_first}(${production.name?cap_first}Node),
[/#list]
}

[#-- Generate struct for each production --]
[#list grammar.parserProductions as production]
/// AST node for ${production.name} production
#[derive(Debug, Clone)]
pub struct ${production.name?cap_first}Node {
    /// Parent node (if any)
    pub parent: Option<NodeId>,
    /// Child nodes
    pub children: Vec<NodeId>,
    /// First token of this node
    pub begin_token: TokenId,
    /// Last token of this node
    pub end_token: TokenId,
}

impl ${production.name?cap_first}Node {
    /// Create a new ${production.name} node
    pub fn new(begin_token: TokenId, end_token: TokenId) -> Self {
        ${production.name?cap_first}Node {
            parent: None,
            children: Vec::new(),
            begin_token,
            end_token,
        }
    }
}

[/#list]
[/#if]
