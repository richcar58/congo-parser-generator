//! ${settings.parserClassName} - Generated by ${generated_by}
//!
//! This parser was automatically generated from: ${settings.filename}
//! Do not edit this file directly. Regenerate from the grammar instead.
//!
//! # Features
//!
//! - **Arena-based allocation**: All AST nodes and tokens are stored in a central arena
//! - **Type-safe indices**: `NodeId` and `TokenId` provide safe references without lifetimes
//! - **Result-based errors**: All parsing operations return `Result<T, ParseError>`
//! - **Location tracking**: Errors include line/column information for better diagnostics
//!
//! # Example
//!
//! ```no_run
//! use ${settings.parserPackage?replace(".", "_")}::*;
//!
//! fn main() -> Result<(), ParseError> {
//!     let input = "your input here".to_string();
//!     let mut parser = Parser::new(input)?;
//!     parser.parse()?;
//!     Ok(())
//! }
//! ```

#![deny(unsafe_code)]
#![warn(missing_docs)]
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]

mod error;
mod tokens;
mod arena;
[#if grammar.productionTable?size > 0]
mod lexer;
mod parser;
[/#if]

// Re-export public API
pub use error::{ParseError, ParseResult};
pub use tokens::{Token, TokenType, LexicalState, TokenSource};
pub use arena::{Arena, NodeId, TokenId, AstNode};
[#if grammar.productionTable?size > 0]
pub use lexer::Lexer;
pub use parser::Parser;

// Re-export AST node types
[#list grammar.parserProductions as production]
pub use arena::${production.name?cap_first}Node;
[/#list]
[/#if]
