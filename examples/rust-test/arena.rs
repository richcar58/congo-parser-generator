//! Arena allocator for AST nodes. Generated by CongoCC Parser Generator. Do not edit.

use crate::tokens::Token;

/// Type-safe index for nodes in the arena
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct NodeId(pub usize);

/// Type-safe index for tokens in the arena
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct TokenId(pub usize);

/// Arena that owns all AST nodes and tokens
pub struct Arena {
    /// All AST nodes
    nodes: Vec<AstNode>,
    /// All tokens
    tokens: Vec<Token>,
}

impl Arena {
    /// Create a new empty arena
    pub fn new() -> Self {
        Arena {
            nodes: Vec::new(),
            tokens: Vec::new(),
        }
    }

    /// Allocate a new node in the arena
    pub fn alloc_node(&mut self, node: AstNode) -> NodeId {
        let id = NodeId(self.nodes.len());
        self.nodes.push(node);
        id
    }

    /// Get a reference to a node
    pub fn get_node(&self, id: NodeId) -> &AstNode {
        &self.nodes[id.0]
    }

    /// Get a mutable reference to a node
    pub fn get_node_mut(&mut self, id: NodeId) -> &mut AstNode {
        &mut self.nodes[id.0]
    }

    /// Allocate a new token in the arena
    pub fn alloc_token(&mut self, token: Token) -> TokenId {
        let id = TokenId(self.tokens.len());
        self.tokens.push(token);
        id
    }

    /// Get a reference to a token
    pub fn get_token(&self, id: TokenId) -> &Token {
        &self.tokens[id.0]
    }
}

impl Default for Arena {
    fn default() -> Self {
        Self::new()
    }
}

/// Enum containing all AST node types
#[derive(Debug, Clone)]
pub enum AstNode {
    /// AST node: Expression
    Expression(ExpressionNode),
    /// AST node: AdditiveExpression
    AdditiveExpression(AdditiveExpressionNode),
    /// AST node: MultiplicativeExpression
    MultiplicativeExpression(MultiplicativeExpressionNode),
    /// AST node: Primary
    Primary(PrimaryNode),
}

/// AST node for Expression production
#[derive(Debug, Clone)]
pub struct ExpressionNode {
    /// Parent node (if any)
    pub parent: Option<NodeId>,
    /// Child nodes
    pub children: Vec<NodeId>,
    /// First token of this node
    pub begin_token: TokenId,
    /// Last token of this node
    pub end_token: TokenId,
}

impl ExpressionNode {
    /// Create a new Expression node
    pub fn new(begin_token: TokenId, end_token: TokenId) -> Self {
        ExpressionNode {
            parent: None,
            children: Vec::new(),
            begin_token,
            end_token,
        }
    }
}

/// AST node for AdditiveExpression production
#[derive(Debug, Clone)]
pub struct AdditiveExpressionNode {
    /// Parent node (if any)
    pub parent: Option<NodeId>,
    /// Child nodes
    pub children: Vec<NodeId>,
    /// First token of this node
    pub begin_token: TokenId,
    /// Last token of this node
    pub end_token: TokenId,
}

impl AdditiveExpressionNode {
    /// Create a new AdditiveExpression node
    pub fn new(begin_token: TokenId, end_token: TokenId) -> Self {
        AdditiveExpressionNode {
            parent: None,
            children: Vec::new(),
            begin_token,
            end_token,
        }
    }
}

/// AST node for MultiplicativeExpression production
#[derive(Debug, Clone)]
pub struct MultiplicativeExpressionNode {
    /// Parent node (if any)
    pub parent: Option<NodeId>,
    /// Child nodes
    pub children: Vec<NodeId>,
    /// First token of this node
    pub begin_token: TokenId,
    /// Last token of this node
    pub end_token: TokenId,
}

impl MultiplicativeExpressionNode {
    /// Create a new MultiplicativeExpression node
    pub fn new(begin_token: TokenId, end_token: TokenId) -> Self {
        MultiplicativeExpressionNode {
            parent: None,
            children: Vec::new(),
            begin_token,
            end_token,
        }
    }
}

/// AST node for Primary production
#[derive(Debug, Clone)]
pub struct PrimaryNode {
    /// Parent node (if any)
    pub parent: Option<NodeId>,
    /// Child nodes
    pub children: Vec<NodeId>,
    /// First token of this node
    pub begin_token: TokenId,
    /// Last token of this node
    pub end_token: TokenId,
}

impl PrimaryNode {
    /// Create a new Primary node
    pub fn new(begin_token: TokenId, end_token: TokenId) -> Self {
        PrimaryNode {
            parent: None,
            children: Vec::new(),
            begin_token,
            end_token,
        }
    }
}

